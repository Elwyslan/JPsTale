# 精灵图片加/解密工具

刚开始研究精灵的图片文件时，我用C++制作做一个BMP图片的加解密工具。后来顺手把精灵使用的TGA图片也看了一下，发现是使用同样原理进行的加密。
此工具现在使用Java重写，并且开源，可以实现对精灵中的BMP、TGA图片进行批量加解密。

UPDATED BY yan@2016/10/27

## 解密原理
精灵图片文件的加密方式，是把BMP文件的前14个字节给篡改成错误的数据。下面是2个例子：

例1：
错误的文件头：
41 38 3A 09 13 19 24 31 40 51 9A 79 90 A9 28 00 WRONG
      3A 09 13 19
正确的文件头：
42 4D 36 00 03 00 00 00 00 00 36 00 00 00 28 00 RIGHT
      36 00 03 00 

例2：
错误的文件头：
41 38 3C B9 14 19 24 31 40 51 9A 79 90 A9 28 00 WRONG
      3C B9 14 19 
正确的文件头：
42 4D 38 B0 04 00 00 00 00 00 36 00 00 00 28 00 RIGHT
      38 B0 04 00 

可以看出，错误的文件头实际上是在正确的文件头基础上，加了一段固定的数据：
01 15-04-09-10-19-24-31-40-51-64-79-90-A9
      04 09 10 19

再仔细看，实际上这14个字节，只有第3、4、5、6这4个位置的字节是变化的，其他位置是不变的。在BMP文件格式中，这4个字节代表文件的实际大小。

我们只要算出文件大小，把其他位的数据复原，替换掉错误的文件头，可以解密了。
例如：
(1) 文件大小：6864
(2) 十六进制：1AD0
(3) 补码：00 00 1A D0
(4) 反向：D0 1A 00 00
(5) 继续补码：
42 4D D0 1A 00 00 00 00 00 00 36 00 00 00 28 00 

## C++代码说明
下面这个是核心函数。其主要功能是根据bmp文件大小来计算正确的文件头。
type = false时解密，type = true时加密。

/*解密 & 加密*/
void CPtBitmapDlg::encrypt(char *filename, unsigned long size, bool type) 
{
	ofstream out;
	out.open(filename, ios::in|ios::out|ios::binary);
	if(out.is_open())
	{
		if (type == false) {
			unsigned char header[14] = {0x42, 0x4D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	0x00, 0x00, 0x36, 0x00, 0x00, 0x00};
			memcpy(aHeader, header, 14);
		}
		else
		{
			unsigned char header[16] = {0x41, 0x38, 0x00, 0x00, 0x00, 0x00, 0x24, 0x31,	0x40, 0x51, 0x9A, 0x79, 0x90, 0xA9};
			memcpy(aHeader, header, 14);
			size += 420481284;// 把文件的实际大小加密，这个数字的16进制为：19 10 09 04，颠倒过来就是04 09 10 19
		}
		
		unsigned char *pLen = (unsigned char *)&size;
		memcpy(&aHeader[2], pLen, 4);// 修改文件大小
		out.write(aHeader, 14);
		out.close();
	}
}

MADE BY 可仪@精灵中国（群号：13463366）
2015-04-07